## KCommon-使用Kotlin编写，基于MVP的极速开发框架
我们在开发Android应用程序的时候其实会有很多通用的代码，比方说很常见的页面的几种基本状态的切换：正常、加载失败、加载中、空页面。又或者是下拉刷新和如果数据需要分页而带来的上拉加载更多数据等等操作。当然，这其中最繁琐的还是关于MVP相关模板代码的编写，熟悉Android中MVP架构的小伙伴们应该都知道，严格按照MVP架构的话，我们每一个Activity或者Fragment都需要多写一个接口和两个实现类：MVPContract、MVPModel和MVPPresenter。而这些Contract、Model和Presenter又不近相似，所以在我之前的开发中，如果一个新的APP有30个页面，那么加上这些MVP架构所需的代码，我需要多添加90个文件，即使是复制粘贴这些代码当时也耗费了我将近2个多小时的时间(当然不仅仅是复制，还包括文件名，方法名称的修改等等所需的细节)。当然，这也是促使我开源出KCommon这个使用Kotlin编写的，基于MVP架构的极速开发框架的主要原因。

#### KCommon可以解决的开发中的痛点
* 页面状态的切换，包括正常、加载失败、加载中、空页面和自定义的页面
* 对下拉刷新和上拉加载更多的逻辑做了完善的处理，极大的减少了开发者的工作量
* 对网络请求框架做了封装，便于方便的请求网络和加载缓存
* 对网络请求返回的错误进行了封装，方便根据错误码进行错误处理
* 提供了自动生成MVP相关文件的模板代码，实现了真正一键创建MVP的所有代码

#### 集成方法
* api 'com.blackflagbin:kcommonlibrary:0.0.11-test'
* 在根目录的gradle文件中添加：
```
allprojects {
    repositories {
        //添加这一行依赖
        maven { url "https://jitpack.io" }
    }
}

```
* 在自定义的Application类中的onCreate方法中初始化：
```
CommonLibrary.instance.initLibrary(this,
                BuildConfig.APP_URL,
                ApiService::class.java,
                CacheService::class.java,
                spName = "KCommonDemo",
                errorHandleMap = hashMapOf<Int, (exception: IApiException) -> Unit>(401 to { exception ->

                }, 402 to { exception ->

                }, 403 to { exception ->

                }),
                isDebug = BuildConfig.DEBUG)
```
* 将[KCommonTemplate模板文件](https://github.com/BlackFlagBin/KCommonTemplate)放到指定位置

#### 详细功能使用说明
如果只是针对不同的模块进行介绍的话，可能不是那么容易理解，这里我结合一个Kotlin编写的[Demo](https://github.com/BlackFlagBin/KCommonProject)，来一步一步详细演示如何使用这个极速开发框架。
##### 明确需求
首先我们这个APP的需求很明确，要有统一的网络错误处理、页面的不同状态切换、下拉刷新和上拉加载更多、处理网络请求时的Loading效果、在无网络时加载缓存数据，和使用MVP架构来编写代码。在这里我使用Kotlin编写整个APP的代码，对Kotlin不熟悉的同学也不用害怕，Java和Kotlin的写法基本是一致的，并且我的MVP模板文件也提供了Kotlin和Java两个版本的选项。

##### 添加依赖，复制模板代码
这两步在集成方法中已经介绍过了。


##### 配置MultiDexEnable
由于KCommon为了方便开发依赖了很多开发中常用的第三方库，完整的依赖如下所示：
```
dependencies {
    api fileTree(include: ['*.jar'], dir: 'libs')
    api 'com.android.support:appcompat-v7:27.1.1'
    api 'com.android.support:recyclerview-v7:27.1.1'
    api 'org.jetbrains.anko:anko:0.10.3'
    api 'androidx.core:core-ktx:0.3'
    api 'com.android.support:multidex:1.0.3'
    api 'com.squareup.okhttp3:okhttp:3.10.0'
    api 'com.squareup.okhttp3:logging-interceptor:3.9.1'
    api 'com.squareup.retrofit2:retrofit:2.4.0'
    api 'com.squareup.retrofit2:converter-gson:2.4.0'
    api 'com.jakewharton.retrofit:retrofit2-rxjava2-adapter:1.0.0'
    api 'io.reactivex.rxjava2:rxandroid:2.0.1'
    api 'com.github.VictorAlbertos.RxCache:runtime:1.8.3-2.x'
    api 'io.reactivex.rxjava2:rxjava:2.1.7'
    api 'com.github.VictorAlbertos.Jolyglot:gson:0.0.4'
    api 'com.jakewharton.rxbinding2:rxbinding:2.0.0'
    api 'com.tbruyelle.rxpermissions2:rxpermissions:0.9.4@aar'
    api 'org.greenrobot:eventbus:3.0.0'
    api 'com.github.CymChad:BaseRecyclerViewAdapterHelper:2.9.35'
    api 'com.github.Kennyc1012:MultiStateView:1.3.0'
    api 'com.github.ybq:Android-SpinKit:1.1.0'
    api 'com.blankj:utilcode:1.17.1'
    api 'com.github.bumptech.glide:glide:3.8.0'
    api 'com.github.anzaizai:EasySwipeMenuLayout:1.1.2'
    api 'com.trello.rxlifecycle2:rxlifecycle:2.2.1'
    api 'com.trello.rxlifecycle2:rxlifecycle-components:2.2.1'
    api 'com.trello.rxlifecycle2:rxlifecycle-kotlin:2.2.1'
    api 'com.trello.rxlifecycle2:rxlifecycle-android-lifecycle-kotlin:2.2.1'
    api 'org.jetbrains.kotlin:kotlin-stdlib:1.2.51'
    api 'com.android.support:cardview-v7:27.1.1'
    api 'com.hx.multi-image-selector:multi-image-selector:1.2.1'
    api 'com.android.support:design:27.1.1'
}
```
所以方法数基本上是要超过65535的，因此需要配置MultiDex：
```
android {
    compileSdkVersion 27
    buildToolsVersion '27.0.3'
    defaultConfig {
        minSdkVersion 19
        targetSdkVersion 27
        versionCode 1
        versionName "1.0"
        //在这里配置multiDex
        multiDexEnabled true
    }
}
```

##### 创建项目的目录结构
由于开发中需要配合KCommonTemplate一键生成相关MVP代码使用，所以对整个项目的目录结构有着要求(如果项目目录不正确的话，一键生成的模板代码文件的位置会错位)。

首先在项目的主包名下创建4个平级的package：**app** 、**common** 、**mvp** 、**ui** 。

根据名称大家也很好理解，**app** 包中存放我们自定义的Application，**common** 包中存放一些通用的基础代码，比如常量、数据类、网络访问接口类等等，**mvp** 包中存放我们MVP架构所需的组件类，**ui** 包中存放我们的Activity、Fragment和Adapter等等与界面相关的类。

* **app** 包中创建我们自定义的Application，Application中的内容之后会详细说明
* **common** 包中创建 **http** 包，里面创建两个接口， **ApiService**  和 **CacheService** 这两个接口的名字是固定的，也是因为模板文件中写死了这两个接口的名字。使用过Retrofit的同学应该都清楚，前者是存放网络请求的接口，而后者是结合RxCache使用的存放缓存方法的接口。如果对RxCache不熟悉的同学或者不需要缓存的同学可以把 **CacheService** 中的内容清空，保持一个空接口即可，但是 **CacheService** 这个接口文件必须存在。
* **mvp** 包中分别创建 **contract** 、 **model**  、 **presenter**  三个包，对MVP架构熟悉的同学应该非常清楚这些，而这些包中的相关代码会在我们创建Activity或Fragment的时候一键生成。
* **ui** 包中创建 **activity** 和 **fragment** ，很好理解了，存放我们开发中的Activity和fragment。

上面这些目录结构都是在一个新的项目开发前必须创建好的。有的同学可能看到我的[Demo](https://github.com/BlackFlagBin/KCommonProject)中在一些目录中也添加了别的一些包，比如在 **common** 包下创建了 **constant** 、 **util** 、 **entity** 等等包。其实除了之前提到的必须的目录结构，你在[Demo](https://github.com/BlackFlagBin/KCommonProject)中看到的别的包都是可选的，这个随你，只不过这些都是我个人的开发习惯。我习惯在 **common** 包下存放我项目中的常量、工具类、和数据实体类，同理，我也喜欢在 **ui** 包下存放adapter和自定义view。当然，这些都是经验之谈，我推荐你跟我采用相同的结构。我们最后来看一张图片有个更明确的概念。
![目录结构](https://github.com/BlackFlagBin/MarkDownPicture/blob/master/kcommon/KCommonProjectIndex.png)


##### 完成我们自定义的Application类
```
class App : Application() {

    companion object {
        fun startLoginActivity(context: Context, loginClazz: Class<*>) {
            CommonLibrary.instance.headerMap = hashMapOf(
                    "token" to SPUtils.getInstance("KCommonDemo").getString("token", "123"))
            context.startActivity(
                    Intent(
                            context,
                            loginClazz).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }

    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        MultiDex.install(this)

    }

    override fun onCreate() {
        super.onCreate()
        if (LeakCanary.isInAnalyzerProcess(this)) {
            // This process is dedicated to LeakCanary for heap analysis.
            // You should not init your app in this process.
            return;
        }
        LeakCanary.install(this)
        BlockCanary.install(this, AppBlockCanaryContext()).start()

        CommonLibrary.instance.initLibrary(this,
                BuildConfig.APP_URL,
                ApiService::class.java,
                CacheService::class.java,
                spName = "KCommonDemo",
                errorHandleMap = hashMapOf<Int, (exception: IApiException) -> Unit>(401 to { exception ->

                }, 402 to { exception ->

                }, 403 to { exception ->

                }),
                isDebug = BuildConfig.DEBUG)
    }
}
```
上面是Demo中自定义的Application，首先要重写这个方法，处理Multidex：
```
    //Multidex
    override fun attachBaseContext(base: Context) {
        super.attachBaseContext(base)
        MultiDex.install(this)
    }
```
然后再onCreate方法中初始化我们的 **CommonLibrary** ：
```
CommonLibrary.instance.initLibrary(this,
                BuildConfig.APP_URL,
                ApiService::class.java,
                CacheService::class.java,
                spName = "KCommonDemo",
                errorHandleMap = hashMapOf<Int, (exception: IApiException) -> Unit>(401 to { exception ->

                }, 402 to { exception ->

                }, 403 to { exception ->

                }),
                isDebug = BuildConfig.DEBUG)
```
这里传入的第一个参数是Application本身，第二个参数是BaseUrl，之后是我们之前提到的APIService和CacheService，之后传入了一个spName，这个表示SharedPrefrence的文件名称，之后是errorHandleMap，这存放了根据不同的网络错误码对应的回调，最后传入一个isDebug表示debug环境下会开启网络日志输入，release环境下会关闭网络日志输出。下面是详细说明：
```
    /**
     * 初始化
     * @param context Application
     * @param baseUrl retrofit所需的baseUrl
     * @param apiClass retrofit使用的ApisService::Class.java
     * @param cacheClass rxcache使用的CacheService::Class.java
     * @param spName Sharedpreference文件名称
     * @param isDebug 是debug环境还是release环境。debug环境有网络请求的日志，release反之
     * @param startPage 分页列表的起始页，有可能是0，或者是2，这个看后台
     * @param pageSize 分页大小
     * @param headerMap 网络请求头的map集合，便于在网络请求添加统一的请求头，比如token之类
     * @param errorHandleMap 错误处理的map集合，便于针对相关网络请求返回的错误码来做相应的处理，比如错误码401，token失效需要重新登录
     * @param onPageCreateListener 对应页面activity或fragment相关生命周期的回调，便于在页面相关时机做一些统一处理，比如加入友盟统计需要在所有页面的相关生命周期加入一些处理
     * @param onPageDestroyListener 对应页面activity或fragment相关生命周期的回调，便于在页面相关时机做一些统一处理，比如加入友盟统计需要在所有页面的相关生命周期加入一些处理
     * @param onPageResumeListener 对应页面activity或fragment相关生命周期的回调，便于在页面相关时机做一些统一处理，比如加入友盟统计需要在所有页面的相关生命周期加入一些处理
     * @param onPagePauseListener 对应页面activity或fragment相关生命周期的回调，便于在页面相关时机做一些统一处理，比如加入友盟统计需要在所有页面的相关生命周期加入一些处理
     *
     */
    fun initLibrary(
            context: Application,
            baseUrl: String,
            apiClass: Class<*>,
            cacheClass: Class<*>,
            spName: String = "kcommon",
            isDebug: Boolean = true,
            startPage: Int = 1,
            pageSize: Int = 20,
            headerMap: Map<String, String>? = null,
            errorHandleMap: Map<Int, (exception: IApiException) -> Unit>? = null,
            onPageCreateListener: OnPageCreateListener? = null,
            onPageDestroyListener: OnPageDestroyListener? = null,
            onPageResumeListener: OnPageResumeListener? = null,
            onPagePauseListener: OnPagePauseListener? = null)
```
当然这些参数中前4个参数都是必须的，因为很明显嘛，它们都没有默认值。其余的参数如果有需要的话是可以按需配置的。

如果是跟着Demo一起看的话，有的小伙伴可能会对APP这段代码中的：
```
companion object {
        fun startLoginActivity(context: Context, loginClazz: Class<*>) {
            CommonLibrary.instance.headerMap = hashMapOf(
                    "token" to SPUtils.getInstance("KCommonDemo").getString("token", "123"))
            context.startActivity(
                    Intent(
                            context,
                            loginClazz).addFlags(Intent.FLAG_ACTIVITY_CLEAR_TASK or Intent.FLAG_ACTIVITY_NEW_TASK))
        }
    }
```
感到疑惑，这里其实是一个伴生对象，可以理解为Java中的静态方法，主要是方便当token过期的时候跳转到登录页面并将之前网络请求中的token这个请求头清空。当然，在我们正在开发的这个Demo中是没有用到的，这里只是提供一种token过期，跳转登录页的思路。

##### 完成网络数据类的编写
在 **common** 包下创建 **entity** 数据类包，之后再 **entity** 包下创建 **net** 网络数据类包，在 **net** 中创建 **DataEntity** 这个数据文件。

这个数据文件如下所示：
```
//最外层数据类
data class HttpResultEntity<T>(
        private var code: Int = 0,
        private var message: String = "",
        private var error: Boolean = false,
        private var results: T) : IHttpResultEntity<T> {
    override val isSuccess: Boolean
        get() = !error
    override val errorCode: Int
        get() = code
    override val errorMessage: String
        get() = message
    override val result: T
        get() = results
}


data class DataItem(
		@SerializedName("desc") var desc: String = "",
		@SerializedName("ganhuo_id") var ganhuoId: String = "",
		@SerializedName("publishedAt") var publishedAt: String = "",
		@SerializedName("readability") var readability: String = "",
		@SerializedName("type") var type: String = "",
		@SerializedName("url") var url: String = "",
		@SerializedName("who") var who: String = ""
)

```

我个人习惯将所有的数据类都写到一个文件中，因为数据类都是很简单的，全部写在一个文件中看起来比较清晰，也便于管理。

**DataEntity** 中有两个数据类，第一个是我们网络返回数据的最外层数据类，可以看到，它实现了一个 **KCommon** 库中定义的一个接口 **IHttpResultEntity** ，我们来看一下这个接口：
```
interface IHttpResultEntity<T> {
    //网络请求结果是否成功
    val isSuccess: Boolean

    //错误码
    val errorCode: Int

    //错误信息
    val errorMessage: String

    //返回的有效数据
    val result: T
}
```
这个接口的意思其实很明显了，注释写的很清楚。那么有些还没进入公司的小伙伴们可能会有问题了：为什么必须要添加一个实现了 **IHttpResultEntity** 接口的数据类呢？

我们先来看一下公司开发中实际返回的数据结构：
```
{"data":null,"code":200,"message":null,"success":true}
```
可以看到返回的数据包含4个部分，正好对应着接口中的4个部分。大多数的公司都会返回类似的数据结构，当然有些会字段名称不一样，也有一些会缺一些字段，这时候我们应该灵活应变。

第二个 **DataItem** 是 **GankApi** 返回的数据结构，比方说下面就是一条数据：
```
{
          "desc": "\u8fd8\u5728\u7528ListView\uff1f", 
          "ganhuo_id": "57334c9d67765903fb61c418", 
          "publishedAt": "2016-05-12T12:04:43.857000", 
          "readability": "", 
          "type": "Android", 
          "url": "http://www.jianshu.com/p/a92955be0a3e", 
          "who": "\u9648\u5b87\u660e"
        }
```

##### 一键生成主页面的MVP相关代码

我们平常写MVP架构的代码，虽然整体页面逻辑看起来非常清晰：Model只管理数据的获取、Presenter管理数据和页面的交互逻辑、View只处理ui相关的事件。但这个清晰是有代价的，文章开篇已经提到过了：我们要多写3个文件 -> **Contract** 、 **Model** 、 **Presenter** 。对，，没错，一个Activity或者Fragment就要多写三个文件，在我短短的开发生涯中，除此之外我还遇到过更过分的，说到这里，可能有的小伙伴要跟我想到一块去了：没错，就是 **Dagger2** ，这个东西首先理解起来有些费劲，其次就是一个Activity或者Fragment也是要多配置2个文件： **Component** 和 **Module** 。相信使用过 **Dagger2** 的朋友都懂我在说什么，那么问题来了，我只想写一个页面，但却要多写5个文件，这简直不可忍受（ **Dagger2** 我已经在新开发的项目中移除了，而且以后也不打算再使用，原因嘛很简单：使用很繁琐，)。












 