## Java面试题
### GC机制
垃圾回收需要完成两件事：找到垃圾，回收垃圾。
找到垃圾一般的话有两种方法：
* 引用计数法
当一个对象被引用时，它的引用计数器会加一，垃圾回收时会清理掉引用计数为0的对象。但这种方法有一个问题，比方说有两个对象A和B，A引用了B，B又引用了A，除此之外没有别的对象引用A和B，那么A和B在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为0，没有达到回收的条件。正因为这个循环引用的问题，Java并没有采用引用计数法。
* 可达性分析法
我们把Java中对象引用的关系看做一张图，从根级对象不可达的对象会被垃圾收集器清除。根级对象一般包括Java虚拟机栈中的对象、本地方法栈中的对象、常量池中的常量。
回收垃圾的话有这么四种方法：
* 标记清除算法
顾名思义分为两步，标记和清除。首先标记到需要回收的垃圾对象，然后回收掉这些垃圾对象。标记清除算法的缺点是清除垃圾对象后会造成内存的碎片化。
* 复制算法
复制算法是将存活的对象复制到另一块内存区域中，并做相应的内存整理工作。复制算法的优点是可以避免内存碎片化，缺点也显而易见，它需要两倍的内存。
* 标记整理算法
标记整理算法也是分两步，先标记后整理。它会标记需要回收的垃圾对象，清除掉垃圾对象后会将存活的对象压缩，避免了内存的碎片化。
* 分代算法
分带算法将对象分为新生代和老年代对象。那么为什么做这样的区分呢？主要是在Java运行中会产生大量对象，这些对象的生命周期会有很大的不同，有的生命周期很长，有的甚至使用一次之后就不再使用。所以针对不同生命周期的对象采用不同的回收策略，这样可以提高GC的效率。
新生代对象分为三个区域：Eden区和两个Survivor区。新创建的对象都放在Eden区，当Eden区的内存达到阈值之后会触发Minor GC，这时会将存活的对象复制到一个Survivor区中，这些存活对象的生命存活计数会加一。这时Eden区会闲置，当再一次达到阈值触发Minor GC时，会将Eden区和之前一个Survivor区中存活的对象复制到另一个可以成为from的Survivor区中，同时它们的生命存活计数也会加一。这个过程会持续很多遍，直到对象的存活计数达到一定的阈值后会触发一个叫做晋升的现象：新生代的这个对象会被放置到老年代中。
老年代中的对象都是经过多次GC依然存活的生命周期很长的Java对象。当老年代的内存达到阈值后会触发Major GC，采用的是标记整理算法。

### JVM内存区域的划分，哪些区域会发生OOM
JVM的内存区域可以分为两类：线程私有和区域和线程共有的区域。
线程私有的区域：程序计数器、JVM虚拟机栈、本地方法栈
线程共有的区域：堆、方法区、运行时常量池
* 程序计数器。每个线程有有一个私有的程序计数器，任何时间一个线程都只会有一个方法正在执行，也就是所谓的当前方法。程序计数器存放的就是这个当前方法的JVM指令地址。
* JVM虚拟机栈。创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用。JVM虚拟机栈有两种操作，分别是压栈和出站。栈帧中存放着局部变量表、方法返回值和方法的正常或异常退出的定义等等。
* 本地方法栈。跟JVM虚拟机栈比较类似，只不过它支持的是Native方法。
* 堆。堆是内存管理的核心区域，用来存放对象实例。几乎所有创建的对象实例都会直接分配到堆上。所以堆也是垃圾回收的主要区域，垃圾收集器会对堆有着更细的划分，最常见的就是把堆划分为新生代和老年代。
* 方法区。方法去主要存放类的结构信息。
* 运行时常量池。运行时常量池位于方法区中，主要存放各种常量信息。

其实除了程序计数器，其他的部分都会发生OOM。
* 堆。通常发生的OOM都会发生在堆中，最常见的可能导致OOM的原因就是内存泄漏。
* JVM虚拟机栈和本地方法栈。当我们写一个递归方法，这个递归方法没有循环终止条件，最终会导致StackOverflow的错误。当然，如果栈空间扩展失败，也是会发生OOM的。
* 方法区。方法区现在基本上不太会发生OOM，但在早期内存中加载的类信息过多的情况下也是会发生OOM的。

### 类加载过程，双亲委派模型
Java中类加载分为3个步骤：加载、链接、初始化。
加载。加载是将字节码数据从不同的数据源读取到JVM内存，并映射为JVM认可的数据结构，也就是Class对象的过程。数据源可以是Jar文件、Class文件等等。如果数据的格式并不是ClassFile的结构，则会报ClassFormatError。
链接。链接是类加载的核心部分，这一步分为3个步骤：验证、准备、解析。
* 验证。验证是保证JVM安全的重要步骤。JVM需要校验字节信息是否符合规范，避免恶意信息和不规范数据危害JVM运行安全。如果验证出错，则会报VerifyError。
* 准备。这一步会创建静态变量，并为静态变量开辟内存空间。
* 解析。这一步会将符号引用替换为直接引用。
初始化。初始化会为静态变量赋值，并执行静态代码块中的逻辑。

双亲委派模型。
类加载器大致分为3类：启动类加载器、扩展类加载器、应用程序类加载器。
启动类加载器主要加载 jre/lib下的jar文件。
扩展类加载器主要加载 jre/lib/ext 下的jar文件。
应用程序类加载器主要加载 classpath下的文件。

所谓的双亲委派模型就是当加载一个类时，会优先使用父类加载器加载，当父类加载器无法加载时才会使用子类加载器去加载。这么做的目的是为了避免类的重复加载。

### HashMap的原理
HashMap的内部可以看做数组+链表的复合结构。数组被分为一个个的桶(bucket)。哈希值决定了键值对在数组中的寻址。具有相同哈希值的键值对会组成链表。需要注意的是当链表长度超过阈值(默认是8)的时候会触发树化，链表会变成树形结构。

把握HashMap的原理需要关注4个方法：hash、put、get、resize。

 hash方法。将key的hashCode值的高位数据移位到低位进行异或运算。这么做的原因是有些key的hashCode值的差异集中在高位，而哈希寻址是忽略容量以上高位的，这种做法可以有效避免哈希冲突。

put方法。put方法主要有以下几个步骤：
* 通过hash方法获取hash值，根据hash值寻址。
* 如果未发生碰撞，直接放到桶中。
* 如果发生碰撞，则以链表形式放在桶后。
* 当链表长度大于阈值后会触发树化，将链表转换为红黑树。
* 如果数组长度达到阈值，会调用resize方法扩展容量。

get方法。get方法主要有以下几个步骤：
* 通过hash方法获取hash值，根据hash值寻址。
* 如果与寻址到桶的key相等，直接返回对应的value。
* 如果发生冲突，分两种情况。如果是树，则调用getTreeNode获取value；如果是链表则通过循环遍历查找对应的value。

resize方法。resize做了两件事：
* 将原数组扩展为原来的2倍
* 重新计算index索引值，将原节点重新放到新的数组中。这一步可以将原先冲突的节点分散到新的桶中。


##  Android面试题
### Handler机制
说到Handler，就不得不提与之密切相关的这几个类：Message、MessageQueue，Looper。
* Message。Message中有两个成员变量值得关注：target和callback。target其实就是发送消息的Handler对象，callback是当调用handler.post(runnable)时传入的Runnable类型的任务。post事件的本质也是创建了一个Message，将我们传入的这个runnable赋值给创建的Message的callback这个成员变量。
* MessageQueue。消息队列很明显是存放消息的队列，值得关注的是MessageQueue中的next()方法，它会返回下一个代处理的消息。
* Looper。Looper消息轮询器其实是连接Handler和消息队列的核心。首先我们都知道，如果想要在一个线程中创建一个Handler，首先要通过Looper.prepare()创建Looper，之后还得调用Looper.loop()开启轮询。我们着重看一下这两个方法。

prepare()。这个方法做了两件事：首先通过ThreadLocal.get()获取当前线程中的Looper,如果不为空，则会抛出一个RunTimeException，意思是一个线程不能创建2个Looper。如果为null则执行下一步。第二步是创建了一个Looper，并通过ThreadLocal.set(looper)。将我们创建的Looper与当前线程绑定。这里需要提一下的是消息队列的创建其实就发生在Looper的构造方法中。

loop()。这个方法开启了整个事件机制的轮询。它的本质是开启了一个死循环，不断的通过MessageQueue的next()方法获取消息。拿到消息后会调用msg.target.dispatchMessage()来做处理。其实我们在说到Message的时候提到过，msg.target其实就是发送这个消息的handler。这句代码的本质就是调用handler的dispatchMessage()。

* Handler。上面做了这么多铺垫，终于到了最重要的部分。Handler的分析着重在两个部分：发送消息和处理消息。

发送消息。其实发送消息除了sendMessage之外还有sendMessageDelayed和post以及postDelayed等等不同的方式。但它们的本质都是调用了sendMessageAtTime。在sendMessageAtTime这个方法中调用了enqueueMessage。在enqueueMessage这个方法中做了两件事：通过msg.target = this实现了消息与当前handler的绑定。然后通过queue.enqueueMessage实现了消息入队。

处理消息。



### Binder机制

### 热修复原理

