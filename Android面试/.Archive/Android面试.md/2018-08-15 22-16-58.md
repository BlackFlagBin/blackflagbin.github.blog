## Java面试题
### GC机制
垃圾回收需要完成两件事：找到垃圾，回收垃圾。
找到垃圾一般的话有两种方法：
* 引用计数法
当一个对象被引用时，它的引用计数器会加一，垃圾回收时会清理掉引用计数为0的对象。但这种方法有一个问题，比方说有两个对象A和B，A引用了B，B又引用了A，除此之外没有别的对象引用A和B，那么A和B在我们看来已经是垃圾对象，需要被回收，但它们的引用计数不为0，没有达到回收的条件。正因为这个循环引用的问题，Java并没有采用引用计数法。
* 可达性分析法
我们把Java中对象引用的关系看做一张图，从根级对象不可达的对象会被垃圾收集器清除。根级对象一般包括Java虚拟机栈中的对象、本地方法栈中的对象、方法区中的静态对象和常量池中的常量。
回收垃圾的话有这么四种方法：
* 标记清除算法
顾名思义分为两步，标记和清除。首先标记到需要回收的垃圾对象，然后回收掉这些垃圾对象。标记清除算法的缺点是清除垃圾对象后会造成内存的碎片化。
* 复制算法
复制算法是将存活的对象复制到另一块内存区域中，并做相应的内存整理工作。复制算法的优点是可以避免内存碎片化，缺点也显而易见，它需要两倍的内存。
* 标记整理算法
标记整理算法也是分两步，先标记后整理。它会标记需要回收的垃圾对象，清除掉垃圾对象后会将存活的对象压缩，避免了内存的碎片化。
* 分代算法
分带算法将对象分为新生代和老年代对象。那么为什么做这样的区分呢？主要是在Java运行中会产生大量对象，这些对象的生命周期会有很大的不同，有的生命周期很长，有的甚至使用一次之后就不再使用。所以针对不同生命周期的对象采用不同的回收策略，这样可以提高GC的效率。
新生代对象分为三个区域：Eden区和两个Survivor区。新创建的对象都放在Eden区，当Eden区的内存达到阈值之后会触发Minor GC，这时会将存活的对象复制到一个Survivor区中，这些存活对象的生命存活计数会加一。这时Eden区会闲置，当再一次达到阈值触发Minor GC时，会将Eden区和之前一个Survivor区中存活的对象复制到另一个Survivor区中，采用的是我之前提到的复制算法，同时它们的生命存活计数也会加一。这个过程会持续很多遍，直到对象的存活计数达到一定的阈值后会触发一个叫做晋升的现象：新生代的这个对象会被放置到老年代中。
老年代中的对象都是经过多次GC依然存活的生命周期很长的Java对象。当老年代的内存达到阈值后会触发Major GC，采用的是标记整理算法。

### JVM内存区域的划分，哪些区域会发生OOM
JVM的内存区域可以分为两类：线程私有和区域和线程共有的区域。
线程私有的区域：程序计数器、JVM虚拟机栈、本地方法栈
线程共有的区域：堆、方法区、运行时常量池
* 程序计数器。每个线程有有一个私有的程序计数器，任何时间一个线程都只会有一个方法正在执行，也就是所谓的当前方法。程序计数器存放的就是这个当前方法的JVM指令地址。
* JVM虚拟机栈。创建线程的时候会创建线程内的虚拟机栈，栈中存放着一个个的栈帧，对应着一个个方法的调用。JVM虚拟机栈有两种操作，分别是压栈和出站。栈帧中存放着局部变量表、方法返回值和方法的正常或异常退出的定义等等。
* 本地方法栈。跟JVM虚拟机栈比较类似，只不过它支持的是Native方法。
* 堆。堆是内存管理的核心区域，用来存放对象实例。几乎所有创建的对象实例都会直接分配到堆上。所以堆也是垃圾回收的主要区域，垃圾收集器会对堆有着更细的划分，最常见的就是把堆划分为新生代和老年代。
* 方法区。方法区主要存放类的结构信息，比如静态属性和方法等等。
* 运行时常量池。运行时常量池位于方法区中，主要存放各种常量信息。

其实除了程序计数器，其他的部分都会发生OOM。
* 堆。通常发生的OOM都会发生在堆中，最常见的可能导致OOM的原因就是内存泄漏。
* JVM虚拟机栈和本地方法栈。当我们写一个递归方法，这个递归方法没有循环终止条件，最终会导致StackOverflow的错误。当然，如果栈空间扩展失败，也是会发生OOM的。
* 方法区。方法区现在基本上不太会发生OOM，但在早期内存中加载的类信息过多的情况下也是会发生OOM的。

### 类加载过程，双亲委派模型
Java中类加载分为3个步骤：加载、链接、初始化。
加载。加载是将字节码数据从不同的数据源读取到JVM内存，并映射为JVM认可的数据结构，也就是Class对象的过程。数据源可以是Jar文件、Class文件等等。如果数据的格式并不是ClassFile的结构，则会报ClassFormatError。
链接。链接是类加载的核心部分，这一步分为3个步骤：验证、准备、解析。
* 验证。验证是保证JVM安全的重要步骤。JVM需要校验字节信息是否符合规范，避免恶意信息和不规范数据危害JVM运行安全。如果验证出错，则会报VerifyError。
* 准备。这一步会创建静态变量，并为静态变量开辟内存空间。
* 解析。这一步会将符号引用替换为直接引用。
初始化。初始化会为静态变量赋值，并执行静态代码块中的逻辑。

双亲委派模型。
类加载器大致分为3类：启动类加载器、扩展类加载器、应用程序类加载器。
启动类加载器主要加载 jre/lib下的jar文件。
扩展类加载器主要加载 jre/lib/ext 下的jar文件。
应用程序类加载器主要加载 classpath下的文件。

所谓的双亲委派模型就是当加载一个类时，会优先使用父类加载器加载，当父类加载器无法加载时才会使用子类加载器去加载。这么做的目的是为了避免类的重复加载。

### HashMap的原理
HashMap的内部可以看做数组+链表的复合结构。数组被分为一个个的桶(bucket)。哈希值决定了键值对在数组中的寻址。具有相同哈希值的键值对会组成链表。需要注意的是当链表长度超过阈值(默认是8)的时候会触发树化，链表会变成树形结构。

把握HashMap的原理需要关注4个方法：hash、put、get、resize。

 hash方法。将key的hashCode值的高位数据移位到低位进行异或运算。这么做的原因是有些key的hashCode值的差异集中在高位，而哈希寻址是忽略容量以上高位的，这种做法可以有效避免哈希冲突。

put方法。put方法主要有以下几个步骤：
* 通过hash方法获取hash值，根据hash值寻址。
* 如果未发生碰撞，直接放到桶中。
* 如果发生碰撞，则以链表形式放在桶后。
* 当链表长度大于阈值后会触发树化，将链表转换为红黑树。
* 如果数组长度达到阈值，会调用resize方法扩展容量。

get方法。get方法主要有以下几个步骤：
* 通过hash方法获取hash值，根据hash值寻址。
* 如果与寻址到桶的key相等，直接返回对应的value。
* 如果发生冲突，分两种情况。如果是树，则调用getTreeNode获取value；如果是链表则通过循环遍历查找对应的value。

resize方法。resize做了两件事：
* 将原数组扩展为原来的2倍
* 重新计算index索引值，将原节点重新放到新的数组中。这一步可以将原先冲突的节点分散到新的桶中。

### 什么情况下Java会产生死锁，如何定位、修复

### sleep和wait的区别
* sleep方法是Thread类中的静态方法，wait是Object类中的方法
* sleep并不会释放同步锁，而wait会释放同步锁
* sleep可以在任何地方使用，而wait只能在同步方法或者同步代码块中使用
* sleep中必须传入时间，而wait可以传，也可以不传，不传时间的话只有notify或者notifyAll才能唤醒，传时间的话在时间之后会自动唤醒

###join的用法
join方法通常是保证线程间顺序调度的一个方法，它是Thread类中的方法。比方说在线程A中执行线程B.join()，这时线程A会进入等待状态，直到线程B执行完毕之后才会唤醒，继续执行A线程中的后续方法。

join方法可以传时间参数，也可以不传参数。传时间参数代表等待线程B执行



### Java中的线程池



### final、finally、finalize区别

final可以修饰类、变量和方法。修饰类代表这个类不可被继承。修饰变量代表此变量不可被改变。修饰方法表示此方法不可被重写(override)。

finally是保证重点代码一定会执行的一种机制。通常是使用try-finally或者try-catch-finally来进行文件流的关闭等操作。

finalize是Object类中的一个方法，它的设计目的是保证对象在垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9已经被标记为deprecated。

### Java中引用类型的区别，具体的使用场景

Java中引用类型分为四类：强引用、软引用、弱引用、虚引用。

强引用：强引用指的是通过new对象创建的引用，垃圾回收器即使是内存不足也不会回收强引用指向的对象。

软引用：软引用是通过SoftRefrence实现的，它的生命周期比强引用短，在内存不足，抛出OOM之前，垃圾回收器会回收软引用引用的对象。软引用常见的使用场景是存储一些内存敏感的缓存，当内存不足时会被回收。

弱引用：弱引用是通过WeakRefrence实现的，它的生命周期比软引用还短，GC只要扫描到弱引用的对象就会回收。弱引用常见的使用场景也是存储一些内存敏感的缓存。

虚引用：虚引用是通过FanttomRefrence实现的，它的生命周期最短，随时可能被回收。如果一个对象只被虚引用引用，我们无法通过虚引用来访问这个对象的任何属性和方法。它的作用仅仅是保证对象在finalize后，做某些事情。虚引用常见的使用场景是跟踪对象被垃圾回收的活动，当一个虚引用关联的对象被垃圾回收器回收之前会收到一条系统通知。

### Exception和Error的区别

Exception和Error都继承于Throwable，在Java中，只有Throwable类型的对象才能被throw或者catch，它是异常处理机制的基本组成类型。

Exception和Error体现了Java对不同异常情况的分类。Exception是程序正常运行中，可以预料的意外情况，可能并且应该被捕获，进行相应的处理。

Error是指在正常情况下，不大可能出现的情况，绝大部分Error都会使程序处于非正常、不可恢复的状态。既然是非正常，所以不便于也不需要捕获，常见的OutOfMemoryError就是Error的子类。

Exception又分为checked Exception和unchecked Exception。checked Exception在代码里必须显式的进行捕获，这是编译器检查的一部分。unchecked Exception也就是运行时异常，类似空指针异常、数组越界等，通常是可以避免的逻辑错误，具体根据需求来判断是否需要捕获，并不会在编译器强制要求。

### volatile
一般提到volatile，就不得不提到内存模型相关的概念。我们都知道，在程序运行中，每条指令都是由CPU执行的，而指令的执行过程中，势必涉及到数据的读取和写入。程序运行中的数据都存放在主存中，这样会有一个问题，由于CPU的执行速度是要远高于主存的读写速度，所以直接从主存中读写数据会降低CPU的效率。为了解决这个问题，就有了高速缓存的概念，在每个CPU中都有高速缓存，它会事先从主存中读取数据，在CPU运算之后在合适的时候刷新到主存中。

这样的运行模式在单线程中是没有任何问题的，但在多线程中，会导致缓存一致性的问题。举个简单的例子：i=i+1 ,在两个线程中执行这句代码，假设i的初始值为0。我们期望两个线程运行后得到2，那么有这样的一种情况，两个线程都从主存中读取i到各自的高速缓存中，这时候两个线程中的i都为0。在线程1执行完毕得到i=1，将之刷新到主存后，线程2开始执行，由于线程2中的i是高速缓存中的0，所以在执行完线程2之后刷新到主存的i仍旧是1。

所以这就导致了对共享变量的缓存一致性的问题，那么为了解决这个问题，提出了缓存一致性协议：当CPU在写数据时，如果发现操作的是共享变量，它会通知其他CPU将它们内部的这个共享变量置为无效状态，当其他CPU读取缓存中的共享变量时，发现这个变量是无效的，它会从新从主存中读取最新的值。

在Java的多线程开发中，有三个重要概念：原子性、可见性、有序性。
原子性：一个或多个操作要么都不执行，要么都执行。
可见性：一个线程中对共享变量(类中的成员变量或静态变量)的修改，在其他线程立即可见。
有序性：程序执行的顺序按照代码的顺序执行。
把一个变量声明为volatile，其实就是保证了可见性和有序性。
可见性我上面已经说过了，在多线程开发中是很有必要的。这个有序性还是得说一下，为了执行的效率，有时候会发生指令重排，这在单线程中指令重排之后的输出与我们的代码逻辑输出还是一致的。但在多线程中就可能发生问题，volatile在一定程度上可以避免指令重排。

volatile的原理是在生成的汇编代码中多了一个lock前缀指令，这个前缀指令相当于一个内存屏障，这个内存屏障有3个作用：
* 确保指令重排的时候不会把屏障后的指令排在屏障前，确保不会把屏障前的指令排在屏障后。
* 修改缓存中的共享变量后立即刷新到主存中。
* 当执行写操作时会导致其他CPU中的缓存无效。

## 网络相关面试题

### http 状态码

### http 与 https 的区别？https 是如何工作的？

##  Android面试题
### Handler机制
说到Handler，就不得不提与之密切相关的这几个类：Message、MessageQueue，Looper。
* Message。Message中有两个成员变量值得关注：target和callback。target其实就是发送消息的Handler对象，callback是当调用handler.post(runnable)时传入的Runnable类型的任务。post事件的本质也是创建了一个Message，将我们传入的这个runnable赋值给创建的Message的callback这个成员变量。
* MessageQueue。消息队列很明显是存放消息的队列，值得关注的是MessageQueue中的next()方法，它会返回下一个代处理的消息。
* Looper。Looper消息轮询器其实是连接Handler和消息队列的核心。首先我们都知道，如果想要在一个线程中创建一个Handler，首先要通过Looper.prepare()创建Looper，之后还得调用Looper.loop()开启轮询。我们着重看一下这两个方法。

prepare()。这个方法做了两件事：首先通过ThreadLocal.get()获取当前线程中的Looper,如果不为空，则会抛出一个RunTimeException，意思是一个线程不能创建2个Looper。如果为null则执行下一步。第二步是创建了一个Looper，并通过ThreadLocal.set(looper)。将我们创建的Looper与当前线程绑定。这里需要提一下的是消息队列的创建其实就发生在Looper的构造方法中。

loop()。这个方法开启了整个事件机制的轮询。它的本质是开启了一个死循环，不断的通过MessageQueue的next()方法获取消息。拿到消息后会调用msg.target.dispatchMessage()来做处理。其实我们在说到Message的时候提到过，msg.target其实就是发送这个消息的handler。这句代码的本质就是调用handler的dispatchMessage()。

* Handler。上面做了这么多铺垫，终于到了最重要的部分。Handler的分析着重在两个部分：发送消息和处理消息。

发送消息。其实发送消息除了sendMessage之外还有sendMessageDelayed和post以及postDelayed等等不同的方式。但它们的本质都是调用了sendMessageAtTime。在sendMessageAtTime这个方法中调用了enqueueMessage。在enqueueMessage这个方法中做了两件事：通过msg.target = this实现了消息与当前handler的绑定。然后通过queue.enqueueMessage实现了消息入队。

处理消息。消息处理的核心其实就是dispatchMessage()这个方法。这个方法里面的逻辑很简单，先判断msg.callback是否为null，如果不为空则执行这个runnable。如果为空则会执行我们的handleMessage方法。

### Android内存优化
Android的内存优化在我看来分为两点：避免内存泄漏、扩大内存，其实就是开源节流。

其实内存泄漏的本质就是较长生命周期的对象引用了较短生命周期的对象。

常见的内存泄漏：
* 单例模式导致的内存泄漏。最常见的例子就是创建这个单例对象需要传入一个Context，这时候传入了一个Activity类型的Context，由于单例对象的静态属性，导致它的生命周期是从单例类加载到应用程序结束为止，所以即使已经finish掉了传入的Activity，由于我们的单例对象依然持有Activity的引用，所以导致了内存泄漏。解决办法也很简单，不要使用Activity类型的Context，使用Application类型的Context可以避免内存泄漏。
* 静态变量导致的内存泄漏。静态变量是放在方法区中的，它的生命周期是从类加载到程序结束，可以看到静态变量生命周期是非常久的。最常见的因静态变量导致内存泄漏的例子是我们在Activity中创建了一个静态变量，而这个静态变量的创建需要传入Activity的引用this。在这种情况下即使Activity调用了finish也会导致内存泄漏。原因就是因为这个静态变量的生命周期几乎和整个应用程序的生命周期一致，它一直持有Activity的引用，从而导致了内存泄漏。
* 非静态内部类导致的内存泄漏。非静态内部类导致内存泄漏的原因是非静态内部类持有外部类的引用，最常见的例子就是在Activity中使用Handler和Thread了。使用非静态内部类创建的Handler和Thread在执行延时操作的时候会一直持有当前Activity的引用，如果在执行延时操作的时候就结束Activity，这样就会导致内存泄漏。解决办法有两种：第一种是使用静态内部类，在静态内部类中使用弱引用调用Activity。第二种方法是在Activity的onDestroy中调用handler.removeCallbacksAndMessages来取消延时事件。
* 使用资源未及时关闭导致的内存泄漏。常见的例子有：操作File未及时关闭，操作Bitmap未及时recycle等等。
* 使用第三方库未能及时解绑。有的三方库提供了注册和解绑的功能，最常见的就是EventBus了，我们都知道使用EventBus要在onCreate中注册，在onDestroy中解绑。如果没有解绑的话，EventBus其实是一个单例模式，他会一直持有Activity的引用，导致内存泄漏。同样常见的还有RxJava，在使用Timer操作符做了一些延时操作后也要注意在onDestroy方法中调用disposable.dispose()来取消操作。
* 属性动画导致的内存泄漏。常见的例子就是在属性动画执行的过程中退出了Activity，这时View对象依然持有Activity的引用从而导致了内存泄漏。解决办法就是在onDestroy中调用动画的cancel方法取消属性动画。
* WebView导致的内存泄漏。WebView比较特殊，即使是调用了它的destroy方法，依然会导致内存泄漏。其实避免WebView导致内存泄漏的最好方法就是让WebView所在的Activity处于另一个进程中，当这个Activity结束时杀死当前WebView所处的进程即可，我记得阿里钉钉的WebView就是另外开启的一个进程，应该也是采用这种方法避免内存泄漏。

扩大内存，为什么要扩大我们的内存呢？有时候我们实际开发中不可避免的要使用很多第三方商业的SDK，这些SDK其实有好有坏，大厂的SDK可能内存泄漏会少一些，但一些小厂的SDK质量也就不太靠谱一些。那应对这种我们无法改变的情况，最好的办法就是扩大内存。

扩大内存通常有两种方法：一个是在清单文件中的Application下添加largeHeap="true"这个属性，另一个就是同一个应用开启多个进程来扩大一个应用的总内存空间。第二种方法其实就很常见了，比方说我使用过个推的SDK，个推的Service其实就是处在另外一个单独的进程中。

Android中的内存优化总的来说就是开源和节流，开源就是扩大内存，节流就是避免内存泄漏。


### Binder机制
在Linux中，为了避免一个进程对其他进程的干扰，进程之间是相互独立的。在一个进程中其实还分为用户空间和内核空间。这里的隔离分为两个部分，进程间的隔离和进程内的隔离。

既然进程间存在隔离，那其实也是存在着交互。进程间通信就是IPC，用户空间和内核空间的通信就是系统调用。

Linux为了保证独立性和安全性，进程之间不能直接相互访问，Android是基于Linux的，所以也是需要解决进程间通信的问题。

其实Linux进程间通信有很多方式，比如管道、socket等等。为什么Android进程间通信采用了Binder而不是Linux已有的方式，主要是有这么两点考虑：性能和安全

性能。在移动设备上对性能要求是比较严苛的。Linux传统的进程间通信比如管道、socket等等进程间通信是需要复制两次数据，而Binder则只需要一次。所以Binder在性能上是由于传统进程通信的。

安全。传统的Linux进程通信是不包含通信双方的身份验证的，这样会导致一些安全性问题。而Binder机制自带身份验证，从而有效的提高了安全性。

Binder是基于CS架构的，有四个主要组成部分。
* Client。客户端进程。
* Server。服务端进程。
* ServiceManager。提供注册、查询和返回代理服务对象的功能。
* Binder驱动。主要负责建立进程间的Binder连接，进程间的数据交互等等底层操作。

Binder机制主要的流程是这样的：
* 服务端通过Binder驱动在ServiceManager中注册我们的服务。
* 客户端通过Binder驱动查询在ServiceManager中注册的服务。
* ServiceManager通过Binder驱动返回服务端的代理对象。
* 客户端拿到服务端的代理对象后即可进行进程间通信。

### LruCache的原理
LruCache的核心原理就是对LinkedHashMap的有效利用，它的内部存在一个LinkedHashMap成员变量。值得我们关注的有四个方法：构造方法、get、put、trimToSize。

构造方法：在LruCache的构造方法中做了两件事，设置了maxSize、创建了一个LinkedHashMap。这里值得注意的是LruCache将LinkedHashMap的accessOrder设置为了true，accessOrder就是遍历这个LinkedHashMap的输出顺序。true代表按照访问顺序输出，false代表按添加顺序输出，因为通常都是按照添加顺序输出，所以accessOrder这个属性默认是false，但我们的LruCache需要按访问顺序输出，所以显式的将accessOrder设置为true。

get方法：本质上是调用LinkedHashMap的get方法，由于我们将accessOrder设置为了true，所以每调用一次get方法，就会将我们访问的当前元素放置到这个LinkedHashMap的尾部。

put方法：本质上也是调用了LinkedHashMap的put方法，由于LinkedHashMap的特性，每调用一次put方法，也会将新加入的元素放置到LinkedHashMap的尾部。添加之后会调用trimToSize方法来保证添加后的内存不超过maxSize。

trimToSize方法：trimToSize方法的内部其实是开启了一个while(true)的死循环，不断的从LinkedHashMap的首部删除元素，直到删除之后的内存小于maxSize之后使用break跳出循环。

其实到这里我们可以总结一下，为什么这个算法叫 **最近最少使用** 算法呢？原理很简单，我们的每次put或者get都可以看做一次访问，由于LinkedHashMap的特性，会将每次访问到的元素放置到尾部。当我们的内存达到阈值后，会触发trimToSize方法来删除LinkedHashMap首部的元素，直到当前内存小于maxSize。为什么删除首部的元素，原因很明显：我们最近经常访问的元素都会放置到尾部，那首部的元素肯定就是 **最近最少使用** 的元素了，因此当内存不足时应当优先删除这些元素。

### DiskLruCache原理


### 设计一个图片的异步加载框架

设计一个图片加载框架，肯定要用到图片加载的三级缓存的思想。三级缓存分为内存缓存、本地缓存和网络缓存。

内存缓存：将Bitmap缓存到内存中，运行速度快，但是内存容量小。
本地缓存：将图片缓存到文件中，速度较慢，但容量较大。
网络缓存：从网络获取图片，速度受网络影响。

如果我们设计一个图片加载框架，流程一定是这样的：
* 拿到图片url后首先从内存中查找BItmap，如果找到直接加载。
* 内存中没有找到，会从本地缓存中查找，如果本地缓存可以找到，则直接加载。
* 内存和本地都没有找到，这时会从网络下载图片，下载到后会加载图片，并且将下载到的图片放到内存缓存和本地缓存中。

上面是一些基本的概念，如果是具体的代码实现的话，大概需要这么几个方面的文件：
* 首先需要确定我们的内存缓存，这里一般用的都是LruCache。
* 确定本地缓存，通常用的是DiskLruCache，这里需要注意的是图片缓存的文件名一般是url被MD5加密后的字符串，为了避免文件名直接暴露图片的url。
* 内存缓存和本地缓存确定之后，需要我们创建一个新的类MemeryAndDiskCache，当然，名字随便起，这个类包含了之前提到的LruCache和DiskLruCache。在MemeryAndDiskCache这个类中我们定义两个方法，一个是getBitmap，另一个是putBitmap，对应着图片的获取和缓存，内部的逻辑也很简单。getBitmap中按内存、本地的优先级去取BItmap，putBitmap中先缓存内存，之后缓存到本地。
* 在缓存策略类确定好之后，我们创建一个ImageLoader类，这个类必须包含两个方法，一个是展示图片displayImage(url,imageView)，另一个是从网络获取图片downloadImage(url,imageView)。在展示图片方法中首先要通过ImageView.setTag(url)，将url和imageView进行绑定，这是为了避免在列表中加载网络图片时会由于ImageView的复用导致的图片错位的bug。之后会从MemeryAndDiskCache中获取缓存，如果存在，直接加载；如果不存在，则调用从网络获取图片这个方法。从网络获取图片方法很多，这里我一般都会使用OkHttp+Retrofit。当从网络中获取到图片之后，首先判断一下imageView.getTag()与图片的url是否一致，如果一致则加载图片，如果不一致则不加载图片，通过这样的方式避免了列表中异步加载图片的错位。同时在获取到图片之后会通过MemeryAndDiskCache来缓存图片。


### Android中的事件分发机制
在我们的手指触摸到屏幕的时候，事件其实是通过 Activity -> ViewGroup -> View 这样的流程到达最后响应我们触摸事件的View。

说到事件分发，必不可少的是这几个方法：dispatchTouchEvent()、onInterceptTouchEvent()、onTouchEvent。接下来就按照 Activity -> ViewGroup -> View 的流程来大致说一下事件分发机制。

我们的手指触摸到屏幕的时候，会触发一个Action_Down类型的事件，当前页面的Activity会首先做出响应，也就是说会走到Activity的dispatchTouchEvent()方法内。在这个方法内部简单来说是这么一个逻辑：
* 调用getWindow.superDispatchTouchEvent()。
* 如果上一步返回true，直接返回true；否则就return自己的onTouchEvent()。
这个逻辑很好理解，getWindow().superDispatchTouchEvent()如果返回true代表当前事件已经被处理，无需调用自己的onTouchEvent；否则代表事件并没有被处理，需要Activity自己处理，也就是调用自己的onTouchEvent。

getWindow()方法返回了一个Window类型的对象，这个我们都知道，在Android中，PhoneWindow是Window的唯一实现类。所以这句本质上是调用了PhoneWindow中的superDispatchTouchEvent()。

而在PhoneWindow的这个方法中实际调用了mDecor.superDispatchTouchEvent(event)。这个mDecor就是DecorView，它是FrameLayout的一个子类，在DecorView中的superDispatchTouchEvent()中调用的是super.dispatchTouchEvent()。到这里就很明显了，DecorView是一个FrameLayout的子类，FrameLayout是一个ViewGroup的子类，本质上调用的还是ViewGroup的dispatchTouchEvent()。

分析到这里，我们的事件已经从Activity传递到了ViewGroup，接下来我们来分析下ViewGroup中的这几个事件处理方法。

在ViewGroup中的dispatchTouchEvent()中的逻辑大致如下：
* 通过onInterceptTouchEvent()判断当前ViewGroup是否拦截事件，默认的ViewGroup都是不拦截的；
* 如果拦截，则return自己的onTouchEvent()；
* 如果不拦截，则根据 child.dispatchTouchEvent()的返回值判断。如果返回true，则return true；否则return自己的onTouchEvent()，在这里实现了未处理事件的向上传递。

通常情况下ViewGroup的onInterceptTouchEvent()都返回false，也就是不拦截。这里需要注意的是事件序列，比如Down事件、Move事件......Up事件，从Down到Up是一个完整的事件序列，对应着手指从按下到抬起这一系列的事件，如果ViewGroup拦截了Down事件，那么后续事件都会交给这个ViewGroup的onTouchEvent。如果ViewGroup拦截的不是Down事件，那么会给之前处理这个Down事件的View发送一个Action_Cancel类型的事件，通知子View这个后续的事件序列已经被ViewGroup接管了，子View恢复之前的状态即可。

这里举一个常见的例子：在一个Recyclerview钟有很多的Button，我们首先按下了一个button，然后滑动一段距离再松开，这时候Recyclerview会跟着滑动，并不会触发这个button的点击事件。这个例子中，当我们按下button时，这个button接收到了Action_Down事件，正常情况下后续的事件序列应该由这个button处理。但我们滑动了一段距离，这时Recyclerview察觉到这是一个滑动操作，拦截了这个事件序列，走了自身的onTouchEvent()方法，反映在屏幕上就是列表的滑动。而这时button仍然处于按下的状态，所以在拦截的时候需要发送一个Action_Cancel来通知button恢复之前状态。

事件分发最终会走到View的dispatchTouchEvent()中。在View的dispatchTouchEvent()中没有onInterceptTouchEvent()，这也很容易理解，View不是ViewGroup，不会包含其他子View，所以也不存在拦截不拦截这一说。忽略一些细节，View的dispatchTouchEvent()中直接return了自己的onTouchEvent()。如果onTouchEvent()返回true代表事件被处理，否则未处理的事件会向上传递，直到有View处理了事件或者一直没有处理，最终到达了Activity的onTouchEvent()终止。

这里经常有人问onTouch和onTouchEvent的区别。首先，这两个方法都在View的dispatchTouchEvent()中，是这么一个逻辑：
* 如果touchListener不为null，并且这个View是enable的，而且onTouch返回的是true，满足这三个条件时会直接return true，不会走onTouchEvent()方法。
* 上面只要有一个条件不满足，就会走到onTouchEvent()方法中。所以onTouch的顺序是在onTouchEvent之前的。



### View的绘制流程
View的绘制流程分为3步：测量、布局、绘制，分别对应3个方法measure、layout、draw。

测量阶段。measure方法会被父View调用，在measure方法中做一些优化和准备工作后会调用onMeasure方法进行实际的自我测量。onMeasure方法在View和ViewGroup做的事情是不一样的：
* View。View中的onMeasure方法会计算自己的尺寸并通过setMeasureDimension保存。
* ViewGroup。ViewGroup中的onMeasure方法会调用所有子View的measure方法进行自我测量并保存。然后通过子View的尺寸和位置计算出自己的尺寸并保存。

布局阶段。layout方法会被父View调用，layout方法会保存父View传进来的尺寸和位置，并调用onLayout进行实际的内部布局。onLayout在View和ViewGroup中做的事情也是不一样的：
* View。因为View是没有子View的，所以View的onLayout里面什么都不做。
* ViewGroup。ViewGroup中的onLayout方法会调用所有子View的layout方法，把尺寸和位置传给他们，让他们完成自我的内部布局。

绘制阶段。draw方法会做一些调度工作，然后会调用onDraw方法进行View的自我绘制。draw方法的调度流程大致是这样的：
* 绘制背景。对应drawBackground(Canvas)方法。
* 绘制主体。对应onDraw(Canvas)方法。
* 绘制子View。对应dispatchDraw(Canvas)方法。
* 绘制滑动相关和前景。对应onDrawForeground(Canvas)。

### Android源码中常见的设计模式以及自己在开发中常用的设计模式

### Android与js是如何交互的
在Android中，Android与js的交互分为两个方面：Android调用js里的方法、js调用Android中的方法。

Android调js。Android调js有两种方法：
* WebView.loadUrl("javascript:js中的方法名")。这种方法的优点是很简洁，缺点是没有返回值，如果需要拿到js方法的返回值则需要js调用Android中的方法来拿到这个返回值。
* WebView.evaluateJavaScript("javascript:js中的方法名",ValueCallback)。这种方法比loadUrl好的是可以通过ValueCallback这个回调拿到js方法的返回值。缺点是这个方法Android4.4才有，兼容性较差。不过放在2018年来说，市面上绝大多数App都要求最低版本是4.4了，所以我认为这个兼容性问题不大。

js调Android。js调Android有三种方法：
* WebView.addJavascriptInterface()。这是官方解决js调用Android方法的方案，需要注意的是要在供js调用的Android方法上加上 **@JavascriptInterface** 注解，以避免安全漏洞。这种方案的缺点是Android4.2以前会有安全漏洞，不过在4.2以后已经修复了。同样，在2018年来说，兼容性问题不大。
* 重写WebViewClient的shouldOverrideUrlLoading()方法来拦截url，拿到url后进行解析，如果符合双方的规定，即可调用Android方法。优点是避免了Android4.2以前的安全漏洞，缺点也很明显，无法直接拿到调用Android方法的返回值，只能通过Android调用js方法来获取返回值。
* 重写WebChromClient的onJsPrompt()方法，同前一个方式一样，拿到url之后先进行解析，如果符合双方规定，即可调用Android方法。最后如果需要返回值，通过result.confirm("Android方法返回值")即可将Android的返回值返回给js。方法的优点是没有漏洞，也没有兼容性限制，同时还可以方便的获取Android方法的返回值。其实这里需要注意的是在WebChromeClient中除了onJsPrompt之外还有onJsAlert和onJsConfirm方法。那么为什么不选择另两个方法呢？原因在于onJsAlert是没有返回值的，而onJsConfirm只有true和false两个返回值，同时在前端开发中prompt方法基本不会被调用，所以才会采用onJsPrompt。

### 热修复原理

### Activity启动过程

### SparseArray原理
SparseArray，通常来讲是Android中用来替代HashMap的一个数据结构。
准确来讲，是用来替换key为Integer类型，value为Object类型的HashMap。需要注意的是SparseArray仅仅实现了Cloneable接口，所以不能用Map来声明。
从内部结构来讲，SparseArray内部由两个数组组成，一个是int[]类型的mKeys，用来存放所有的键；另一个是Object[]类型的mValues，用来存放所有的值。
最常见的是拿SparseArray跟HashMap来做对比，由于SparseArray内部组成是两个数组，所以占用内存比HashMap要小。我们都知道，增删改查等操作都首先需要找到相应的键值对，而SparseArray内部是通过二分查找来寻址的，效率很明显要低于HashMap的常数级别的时间复杂度。提到二分查找，这里还需要提一下的是二分查找的前提是数组已经是排好序的，没错，SparseArray中就是按照key进行升序排列的。
综合起来来说，SparseArray所占空间优于HashMap，而效率低于HashMap，是典型的时间换空间，适合较小容量的存储。
从源码角度来说，我认为需要注意的是SparseArray的remove()、put()和gc()方法。
* remove()。SparseArray的remove()方法并不是直接删除之后再压缩数组，而是将要删除的value设置为DELETE这个SparseArray的静态属性，这个DELETE其实就是一个Object对象，同时会将SparseArray中的mGarbage这个属性设置为true，这个属性是便于在合适的时候调用自身的gc()方法压缩数组来避免浪费空间。这样可以提高效率，如果将来要添加的key等于删除的key，那么会将要添加的value覆盖DELETE。
* gc()。SparseArray中的gc()方法跟JVM的GC其实完全没有任何关系。gc()方法的内部实际上就是一个for循环，将value不为DELETE的键值对往前移动覆盖value为DELETE的键值对来实现数组的压缩，同时将mGarbage置为false，避免内存的浪费。
* put()。put方法是这么一个逻辑，如果通过二分查找在mKeys数组中找到了key，那么直接覆盖value即可。如果没有找到，会拿到与数组中与要添加的key最接近的key索引，如果这个索引对应的value为DELETE，则直接把新的value覆盖DELETE即可，在这里提高了效率。如果value不为DELETE，会判断mGarbage，如果为true，则会调用gc()方法压缩数组，之后会找到合适的索引，将索引之后的键值对后移，插入新的键值对，这个过程中可能会触发数组的扩容。

### 图片加载如何避免OOM
我们知道内存中的Bitmap大小的计算公式是：长所占像素 \* 宽所占像素 \* 每个像素所占内存。想避免OOM有两种方法：等比例缩小长宽、减少每个像素所占的内存。
* 等比缩小长宽。我们知道Bitmap的创建是通过BitmapFactory的工厂方法，decodeFile()、decodeStream()、decodeByteArray()、decodeResource()。这些方法中都有一个Options类型的参数，这个Options是BitmapFactory的内部类，存储着BItmap的一些信息。Options中有一个属性：inSampleSize。我们通过修改inSampleSize可以缩小图片的长宽，从而减少BItmap所占内存。需要注意的是这个inSampleSize大小需要是2的幂次方，如果小于1，代码会强制让inSampleSize为1。
* 减少像素所占内存。Options中有一个属性inPreferredConfig，默认是ARGB_8888，代表每个像素所占尺寸。我们可以通过将之修改为RGB_565或者ARGB_4444来减少一半内存。

### 大图加载
加载高清大图，比如清明上河图，首先屏幕是显示不下的，而且考虑到内存情况，也不可能一次性全部加载到内存。这时候就需要局部加载了，Android中有一个负责局部加载的类：BitmapRegionDecoder。使用方法很简单，通过BitmapRegionDecoder.newInstance()创建对象，之后调用decodeRegion(Rect rect, BitmapFactory.Options options)即可。第一个参数rect是要显示的区域，第二个参数是BitmapFactory中的内部类Options。


## Android三方库的源码分析
由于源码分析篇幅太大，所以这里之贴出我的源码分析的链接(掘金)。

### OkHttp
[OkHttp源码分析](https://juejin.im/post/5af4482951882567286064e6)

### Retrofit
[Retrofit源码分析1](https://juejin.im/post/5ad6094e6fb9a028e1207792)
[Retrofit源码分析2](https://juejin.im/post/5ad6099c518825555d47c4cb)
[Retrofit源码分析3](https://juejin.im/post/5afd81f2f265da0ba06360f7)

### RxJava
[RxJava源码分析](https://juejin.im/post/5afc34396fb9a07aad17b686)

### Glide
[Glide源码分析](https://juejin.im/post/5af95dc66fb9a07aad17a4c3)

### EventBus
[EventBus源码分析](https://juejin.im/post/5aeffc6ff265da0b7b35d3d9)



## 数据结构与算法

### 手写快排
### 手写归并排序
### 手写堆以及堆排序
### 说一下排序算法的区别(时间复杂度和空间复杂度)

